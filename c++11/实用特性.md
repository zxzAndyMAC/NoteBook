[https://subingwen.cn]

# 目录
* [1.字符串原始字面量](#字符串原始字面量) 
* [2.nullptr](#nullptr) 
* [3.constexpr](#constexpr) 
* [4.auto](#auto) 
* [5.decltype](#decltype)  
* [6.返回值类型后置](#返回值类型后置)  
* [7.final，override](#final，override)  
* [8.函数模板的默认模板参数](#函数模板的默认模板参数)  
* [9.using](#using)  
* [10.委托构造函数](#委托构造函数)  
* [11.继承构造函数](#继承构造函数)  
* [12.统一的数据初始化方式-初始化列表](#统一的数据初始化方式-初始化列表)  
* [13.std::initializer_list](#std::initializer_list)  
* [14.基于范围的for循环](#基于范围的for循环)  
* [15.可调用对象](#可调用对象)  
* [16.可调用对象包装器function的使用](#可调用对象包装器function的使用)  
* [17.可调用对象绑定器](#可调用对象绑定器)  
* [18.lambda表达式](#lambda表达式)  
***

# <span id="字符串原始字面量">1.字符串原始字面量</span>
避开转义符，输出原始字符串，使用方式：
```c++
string a = R"(D:\work)";
string b = R"(hello
              world
              !)";
string c = R"Tag(小括号左右注释要一致)Tag"
```

# <span id="nullptr">2.nullptr</span>
NULL在c++中为0，在c中为void*，再调用多态方法的时候会存在歧义
```c++
void func(int a){}
void func(char *a){}

func(NULL);   //调用func(int a)
func(nullptr); //调用func(char *a)
```

# <span id="constexpr">3.constexpr</span>
constexpr表示这玩意儿在编译期就可以算出来（前提是为了算出它所依赖的东西也是在编译期可以算出来的）。而const只保证了运行时不直接被修改（但这个东西仍然可能是个动态变量）。

# <span id="auto">4.auto</span>
```c++
int p = 4;
const auto a1 = p; //const int
auto a2 = a1;   //int
auto* a3 = &a1; //const int*
auto& a4 = a1;  //const int&

const auto a5 = &p; //int *const
auto a6 = a5; //int *
auto *a7 = a5; //int *

const auto* a8 = &p; //const *int
auto a9 = a8; //const *int
auto a10 = a8; //const *int
```
* 1.不能作为函数参数使用
* 2.不能用于类的非静态成员变量初始化，只能用于静态常量初始化
* 3.不能定义数组
* 4.无法使用auto推导出模版参数

# <span id="decltype">5.decltype</span>
* decltype + 变量
  ```c++
    const int ci = 0, &cj = ci;

    // x的类型是const int
    decltype(ci) x = 0;

    // y的类型是const int &
    decltype(cj) y = x;
  ```
* decltype + 表达式
  ```c++
    int i = 42, *p = &i, &r = i;

    // r + 0是一个表达式
    // 算术表达式返回右值
    // b是一个int类型
    decltype(r + 0) b;

    // c是一个int &
    decltype(*p) c = i;

    int i = 42;

    // 加了括号，变成了表达式
    // 返回的是i的左值形式
    // 因此ri的类型是int &
    decltype((i)) ri = i;
  ```
  这里注意一下decltype(*p)。

  解引用运算符*作用于指针类型，得到了p指向的对象的左值（*p = 2很正确），p是指向int的指针，因此decltype(*p)得到的类型是int &

* decltype + 函数
  ```c++
    // 声明了一个函数类型
    using FuncType = int(int &, int);

    // 下面的函数就是上面的类型
    int add_to(int &des, int ori);

    // 声明了一个FuncType类型的指针
    // 并使用函数add_to初始化
    FuncType *pf = add_to;

    //我们可以使用decltype获得函数add_to的类型
    decltype(add_to) *pf = add_to;

    int a = 4;

    // 通过函数指针调用add_to
    pf(a, 2);

  ```

# <span id="返回值类型后置">6.返回值类型后置</span>
```c++
template<typename T, typename U>
auto func(T t, U u) -> decltype(t+u) {
    return t+u;
}
```

# <span id="final，override">7.final，override</span>
* final修饰虚函数防止子类重写
* final修饰类 防止被继承

# <span id="函数模板的默认模板参数">8.函数模板的默认模板参数</span>
```c++
using namespace std;

template<typename T = long, typename U = int>
void test(T t='A', U u='B') {
    cout << "t: " << t << ", u: " << u << endl;
}

int main(int argc, const char * argv[]) {
    test();
    test('a','b');
    test<int>('a', 'b');
    test<char>('a', 'b');
    test<char, int>('a', 'b');
    test<int, char>('a', 'b');
    
    return 0;
}
```

# <span id="using">9.using</span>
可读性强，并且可以给模板起别名
```c++
using 新的类型 = 旧的类型;
using  uint_t = int;

int test(int a, string b){}

typedef int(*func)(int,string);
using func1 = int(*)(int, string);

func1 f = test;

template<typename T>
class Container 
{
public:
    void print(T& t)
    {
        auto it = t.begin()
        for(; it!=t.end(); ++it)
        {
            cout << it->first << "," << it->second << endl;
        }
    }
};

//给模板定义别名，typedef无法实现，using可以
template <typename T>
//typedef map<int T> mapType; //error 需要外面包一层
struct MyMap
{
    typedef map<int T> mapType;
}

MyMap<int>::mapType m1;
MyMap<double>::mapType m2;
Container<MyMap<int>::mapType> c1;
c1.print(m1);

//using
template <typename T>
using MMap = map<int, T>;

MMap<string> mm3;
Container<MMap<string>> c2;
c2.print(mm3);
```

# <span id="委托构造函数">10.委托构造函数</span>
去除冗余代码
```c++
class test {
public:
    test() {};
//    test(int a)
//    {
//        this->_a = a;
//    }
//
//    test(int a, int b)
//    {
//        this->_a = a;
//        this->_b = b;
//    }
//
//    test(int a, int b, int c)
//    {
//        this->_a = a;
//        this->_b = b;
//        this->_c = c;
//    }
    test(int a)
    {
        this->_a = a;
    }
    
    test(int a, int b):test(a)
    {
        this->_b = b;
    }
    
    test(int a, int b, int c):test(a, b)
    {
        this->_c = c;
    }
private:
    int _a, _b, _c;
};
```

# <span id="继承构造函数">11.继承构造函数</span>
```c++
class Base {
public:
    Base(int a){};
    Base(int a, int b){};
    
    void func(int a){};
};

class Child : public Base {
public:
    using Base::Base;
    
    using Base::func;
    void func(){};
};
```

# <span id="统一的数据初始化方式-初始化列表">12.统一的数据初始化方式-初始化列表</span>

# <span id="std::initializer_list">13.std::initializer_list</span>
```c++
void func(initializer_list<int> ls)
{
    auto it = ls.begin();
    for(; it!=ls.end(); ++it)
    {
        cout << *it << " ";
    }
    cout << endl;
}

int main(int argc, const char * argv[]) {
    func({1,2,3,4,5,6});
    
    return 0;
}
```

# <span id="基于范围的for循环">14.基于范围的for循环</span>

```c++
vector<int> t{1,2,3,4};
for (auto item : t) //拷贝
{
    cout << item;
}
cout << endl;

for (auto &item : t) //引用
{
    cout << item;
}
cout << endl;

for (const auto &item : t) //只读引用
{
    cout << item;
}

////////////////////////////
map<int,string> m{{1,"andy"}, {2,"mike"}};
    
for (auto it = m.begin(); it!=m.end(); ++it) {
    cout << it->first << ", " << it->second;
}
cout << endl;
for(auto &it : m) {
    cout << it.first << " ," << it.second;
}
```
注意：set容器元素只读，map的key只读

# <span id="可调用对象">15.可调用对象</span>
```c++
using namespace std;

/**
 1.函数指针
 */
void print(int a, string b) {
    
}

using funcptr = void(*)(int,string);

/**
 2.具有operator()成员函数的类对象（仿函数）
 */

/**
 3.可被转换为函数指针的类对象
 */

/**
 4.类的函数指针或者类的成员指针
 */
class Test {
public:
    //2.具有operator()成员函数的类对象（仿函数）
    void operator () (string msg) {
        cout << "仿函数：" << msg << endl;
    }
    
    //3.将类对象转换为函数指针
    operator funcptr() {
        //return hello;
        return world;
    }
    
    void hello(int a, string s) {
        
    }
    
    static void world(int a, string s) {
        cout << "num: " << a << " name:" << s << endl;
    }
    
    int m_i;
};


int main() {
    Test a;
    a("hello");
    
    Test tt;
    tt(1, "lucy");
    
    funcptr f = Test::world;
    
    using fptr = void(Test::*)(int, string);
    fptr f1 = &Test::hello;
    
    //类的成员指针
    using ptr = int Test::*;
    ptr p = &Test::m_i;
    
    Test ttt;
    (ttt.*f1)(1, "2");
    ttt.*p = 100;
    
    return 1;
}

```

# <span id="可调用对象包装器function的使用">16.可调用对象包装器function的使用</span>
```c++
//1.包装普通函数
function<void(int, string)> f1 = print;

//2.包装类的静态函数
function<void(int, string)> f2 = Test::world;

//3.包装仿函数
Test ta;
function<void(string)> f3 = ta;

//4.包装转化为函数指针的对象
Test tb;
function<void(int, string)> f4 = tb;

//调用
f1(1, "");
f2(2, "");
f3("");
f4(3, "");
```

# <span id="可调用对象绑定器">17.可调用对象绑定器</span>
```c++
using namespace std;

void testFunc(int a, int b, const function<void(int, int)>& f) {
    f(a, b);
}

void output(int a, int b) {
    cout << a << "; " << b << endl;
}

class Test {
public:
    void output(int a, int b) {
        
    }
    
    int count(int a, int b) {
        return a+b;
    }
    
    int m_num = 100;
};

int main() {
    //绑定固定参数
    bind(output, 1, 2)();
    //绑定部分固定参数
    bind(output, 1, placeholders::_1)(12);
    bind(output, placeholders::_1, 2)(12);
    
    bind(output, placeholders::_1, placeholders::_2)(1, 2);
    
    auto f = bind(output, placeholders::_1, placeholders::_2);
    testFunc(1, 1, f);
    
    //成员函数绑定
    Test t;
    auto f2 = bind(&Test::output, &t, 520, placeholders::_1);
    f2(1);
    
    //成员变量
    auto f3 = bind(&Test::m_num, &t);
    f3();
    f3() = 666;
    
    //包装
    function<void(int, int)> b1 = f2;
    
    function<int(int, int)> b3 = bind(&Test::count, &t, 2, 2);
    
    function<int&(void)> b2 = f3; //包装的成员变量绑定器可读可写，所以为&
    b2();
    b2() = 888;
    
    return 1;
}
```


# <span id="lambda表达式">18.lambda表达式</span>
lambda 表达式定义了一个匿名函数，并且可以捕获一定范围内的变量。lambda 表达式的语法形式简单归纳如下：
```c++
[capture](params) opt -> ret {body;};
```
其中 ```capture``` 是捕获列表，```params``` 是参数列表，```opt``` 是函数选项，```ret``` 是返回值类型，```body``` 是函数体。  
&emsp;
1. 捕获列表 []: 捕获一定范围内的变量
2. 参数列表 (): 和普通函数的参数列表一样，如果没有参数参数列表可以省略不写。  
    ```c++
    auto f = [](){return 1;}	// 没有参数, 参数列表为空
    auto f = []{return 1;}		// 没有参数, 参数列表省略不写
    ```
3. opt 选项， ```不需要可以省略```  

    * mutable: 可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）
    * exception: 指定函数抛出的异常，如抛出整数类型的异常，可以使用 throw ();  

4. 返回值类型：在 C++11 中，lambda 表达式的返回值是通过返回值后置语法来定义的。
5. 函数体：函数的实现，这部分不能省略，但函数体可以为空。

### 2. 捕获列表
lambda 表达式的捕获列表可以捕获一定范围内的变量，具体使用方式如下：  

* ```[]```  不捕捉任何变量
* ```[&]``` - 捕获外部作用域中所有变量，并作为引用在函数体内使用 ```(按引用捕获)```
* ```[=]``` - 捕获外部作用域中所有变量，并作为副本在函数体内使用 ```(按值捕获)```
    - ```拷贝的副本在匿名函数体内部是只读的```
* ```[=, &foo]``` - 按值捕获外部作用域中所有变量，并按照引用捕获外部变量 foo
* ```[bar]``` - 按值捕获``` bar``` 变量，同时不捕获其他变量
* ```[&bar]``` - 按引用捕获 bar 变量，同时不捕获其他变量
* ```[this]``` - 捕获当前类中的 this 指针
    - ```让 lambda 表达式拥有和当前类成员函数同样的访问权限```
    - ```如果已经使用了 & 或者 =, 默认添加此选项```

```c++
#include <iostream>
#include <functional>
using namespace std;

class Test
{
public:
    void output(int x, int y)
    {
        auto x1 = [] {return m_number; };                      // error
        auto x2 = [=] {return m_number + x + y; };             // ok
        auto x3 = [&] {return m_number + x + y; };             // ok
        auto x4 = [this] {return m_number; };                  // ok
        auto x5 = [this] {return m_number + x + y; };          // error
        auto x6 = [this, x, y] {return m_number + x + y; };    // ok
        auto x7 = [this] {return m_number++; };                // ok
    }
    int m_number = 100;
};
```
* ```x1```：错误，没有捕获外部变量，不能使用类成员 m_number
* ```x2```：正确，以值拷贝的方式捕获所有外部变量
* ```x3```：正确，以引用的方式捕获所有外部变量
* ```x4```：正确，捕获 this 指针，可访问对象内部成员
* ```x5```：错误，捕获 this 指针，可访问类内部成员，没有捕获到变量 x，y，因此不能访问。
* ```x6```：正确，捕获 this 指针，x，y
* ```x7```：正确，捕获 this 指针，并且可以修改对象内部变量的值

```c++
int main(void)
{
    int a = 10, b = 20;
    auto f1 = [] {return a; };                        // error
    auto f2 = [&] {return a++; };                     // ok
    auto f3 = [=] {return a; };                       // ok
    auto f4 = [=] {return a++; };                     // error
    auto f5 = [a] {return a + b; };                   // error
    auto f6 = [a, &b] {return a + (b++); };           // ok
    auto f7 = [=, &b] {return a + (b++); };           // ok

    return 0;
}
```
* ```f1```：错误，没有捕获外部变量，因此无法访问变量 a
* ```f2```：正确，使用引用的方式捕获外部变量，可读写
* ```f3```：正确，使用值拷贝的方式捕获外部变量，可读
* ```f4```：错误，使用值拷贝的方式捕获外部变量，可读不能写
* ```f5```：错误，使用拷贝的方式捕获了外部变量 a，没有捕获外部变量 b，因此无法访问变量 b
* ```f6```：正确，使用拷贝的方式捕获了外部变量 a，只读，使用引用的方式捕获外部变量 b，可读写
* ```f7```：正确，使用值拷贝的方式捕获所有外部变量以及 b 的引用，b 可读写，其他只读  

<font color=green size=3>
在匿名函数内部，需要通过 lambda 表达式的捕获列表控制如何捕获外部变量，以及访问哪些变量。默认状态下 lambda 表达式无法修改通过复制方式捕获外部变量，如果希望修改这些外部变量，需要通过引用的方式进行捕获。</font>  
  
&emsp;

### 3. 返回值
很多时候，lambda 表达式的返回值是非常明显的，因此在 C++11 中允许省略 lambda 表达式的返回值。
```c++
// 完整的lambda表达式定义
auto f = [](int a) -> int
{
    return a+10;  
};

// 忽略返回值的lambda表达式定义
auto f = [](int a)
{
    return a+10;  
};
```

一般情况下，不指定 lambda 表达式的返回值，编译器会根据 return 语句自动推导返回值的类型，```但需要注意的是 labmda表达式不能通过列表初始化自动推导出返回值类型。```
```c++
// ok，可以自动推导出返回值类型
auto f = [](int i)
{
    return i;
}

// error，不能推导出返回值类型
auto f1 = []()
{
    return {1, 2};	// 基于列表初始化推导返回值，错误
}
```  
&emsp;

### 3.  函数本质
使用 lambda 表达式捕获列表捕获外部变量，如果希望去修改按值捕获的外部变量，那么应该如何处理呢？这就需要使用 mutable 选项，```被mutable修改是lambda表达式就算没有参数也要写明参数列表，并且可以去掉按值捕获的外部变量的只读（const）属性。```
```c++
int a = 0;
auto f1 = [=] {return a++; };              // error, 按值捕获外部变量, a是只读的
auto f2 = [=]()mutable {return a++; };     // ok
```  
最后再剖析一下为什么通过值拷贝的方式捕获的外部变量是只读的:  
* ```1.lambda表达式的类型在C++11中会被看做是一个带operator()的类，即仿函数。  ```
* ```2.按照C++标准，lambda表达式的operator()默认是const的，一个const成员函数是无法修改成员变量值的。```  

```mutable 选项的作用就在于取消 operator () 的 const 属性。```

因为 lambda 表达式在 C++ 中会被看做是一个仿函数，因此```可以使用std::function和std::bind来存储和操作lambda表达式：```
```c++
#include <iostream>
#include <functional>
using namespace std;

int main(void)
{
    // 包装可调用函数
    std::function<int(int)> f1 = [](int a) {return a; };
    // 绑定可调用函数
    std::function<int(int)> f2 = bind([](int a) {return a; }, placeholders::_1);

    // 函数调用
    cout << f1(100) << endl;
    cout << f2(200) << endl;
    return 0;
}
```
```对于没有捕获任何变量的 lambda 表达式，还可以转换成一个普通的函数指针：```
```c++
using func_ptr = int(*)(int);
// 没有捕获任何外部变量的匿名函数
func_ptr f = [](int a)
{
    return a;  
};
// 函数调用
f(1314);
```




