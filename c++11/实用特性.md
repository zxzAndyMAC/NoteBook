[https://subingwen.cn]
#### <font color=red size=4>1.字符串原始字面量</font>
避开转义符，输出原始字符串，使用方式：
```c++
string a = R"(D:\work)";
string b = R"(hello
              world
              !)";
string c = R"Tag(小括号左右注释要一致)Tag"
```

#### <font color=red size=4>2.nullptr</font>
NULL在c++中为0，在c中为void*，再调用多态方法的时候会存在歧义
```c++
void func(int a){}
void func(char *a){}

func(NULL);   //调用func(int a)
func(nullptr); //调用func(char *a)
```

#### <font color=red size=4>3.constexpr</font>
constexpr表示这玩意儿在编译期就可以算出来（前提是为了算出它所依赖的东西也是在编译期可以算出来的）。而const只保证了运行时不直接被修改（但这个东西仍然可能是个动态变量）。

#### <font color=red size=4>4.auto</font>
```c++
int p = 4;
const auto a1 = p; //const int
auto a2 = a1;   //int
auto* a3 = &a1; //const int*
auto& a4 = a1;  //const int&

const auto a5 = &p; //int *const
auto a6 = a5; //int *
auto *a7 = a5; //int *

const auto* a8 = &p; //const *int
auto a9 = a8; //const *int
auto a10 = a8; //const *int
```
* 1.不能作为函数参数使用
* 2.不能用于类的非静态成员变量初始化，只能用于静态常量初始化
* 3.不能定义数组
* 4.无法使用auto推导出模版参数

#### <font color=red size=4>5.decltype</font>
* decltype + 变量
  ```c++
    const int ci = 0, &cj = ci;

    // x的类型是const int
    decltype(ci) x = 0;

    // y的类型是const int &
    decltype(cj) y = x;
  ```
* decltype + 表达式
  ```c++
    int i = 42, *p = &i, &r = i;

    // r + 0是一个表达式
    // 算术表达式返回右值
    // b是一个int类型
    decltype(r + 0) b;

    // c是一个int &
    decltype(*p) c = i;

    int i = 42;

    // 加了括号，变成了表达式
    // 返回的是i的左值形式
    // 因此ri的类型是int &
    decltype((i)) ri = i;
  ```
  这里注意一下decltype(*p)。

  解引用运算符*作用于指针类型，得到了p指向的对象的左值（*p = 2很正确），p是指向int的指针，因此decltype(*p)得到的类型是int &

* decltype + 函数
  ```c++
    // 声明了一个函数类型
    using FuncType = int(int &, int);

    // 下面的函数就是上面的类型
    int add_to(int &des, int ori);

    // 声明了一个FuncType类型的指针
    // 并使用函数add_to初始化
    FuncType *pf = add_to;

    //我们可以使用decltype获得函数add_to的类型
    decltype(add_to) *pf = add_to;

    int a = 4;

    // 通过函数指针调用add_to
    pf(a, 2);

  ```

#### <font color=red size=4>6.返回值类型后置</font>
```c++
template<typename T, typename U>
auto func(T t, U u) -> decltype(t+u) {
    return t+u;
}
```

### <font color=red size=4>7.final，override</font>
* final修饰虚函数防止子类重写
* final修饰类 防止被继承

### <font color=red size=4>8.函数模板的默认模板参数</font>
```c++
using namespace std;

template<typename T = long, typename U = int>
void test(T t='A', U u='B') {
    cout << "t: " << t << ", u: " << u << endl;
}

int main(int argc, const char * argv[]) {
    test();
    test('a','b');
    test<int>('a', 'b');
    test<char>('a', 'b');
    test<char, int>('a', 'b');
    test<int, char>('a', 'b');
    
    return 0;
}
```

### <font color=red size=4>9.using</font>
可读性强，并且可以给模板起别名
```c++
using 新的类型 = 旧的类型;
using  uint_t = int;

int test(int a, string b){}

typedef int(*func)(int,string);
using func1 = int(*)(int, string);

func1 f = test;

template<typename T>
class Container 
{
public:
    void print(T& t)
    {
        auto it = t.begin()
        for(; it!=t.end(); ++it)
        {
            cout << it->first << "," << it->second << endl;
        }
    }
};

//给模板定义别名，typedef无法实现，using可以
template <typename T>
//typedef map<int T> mapType; //error 需要外面包一层
struct MyMap
{
    typedef map<int T> mapType;
}

MyMap<int>::mapType m1;
MyMap<double>::mapType m2;
Container<MyMap<int>::mapType> c1;
c1.print(m1);

//using
template <typename T>
using MMap = map<int, T>;

MMap<string> mm3;
Container<MMap<string>> c2;
c2.print(mm3);
```

### <font color=red size=4>10.委托构造函数</font>
去除冗余代码
```c++
class test {
public:
    test() {};
//    test(int a)
//    {
//        this->_a = a;
//    }
//
//    test(int a, int b)
//    {
//        this->_a = a;
//        this->_b = b;
//    }
//
//    test(int a, int b, int c)
//    {
//        this->_a = a;
//        this->_b = b;
//        this->_c = c;
//    }
    test(int a)
    {
        this->_a = a;
    }
    
    test(int a, int b):test(a)
    {
        this->_b = b;
    }
    
    test(int a, int b, int c):test(a, b)
    {
        this->_c = c;
    }
private:
    int _a, _b, _c;
};
```

### <font color=red size=4>11.继承构造函数</font>
```c++
class Base {
public:
    Base(int a){};
    Base(int a, int b){};
    
    void func(int a){};
};

class Child : public Base {
public:
    using Base::Base;
    
    using Base::func;
    void func(){};
};
```

### <font color=red size=4>12.统一的数据初始化方式-初始化列表</font>

### <font color=red size=4>13.std::initializer_list</font>
```c++
void func(initializer_list<int> ls)
{
    auto it = ls.begin();
    for(; it!=ls.end(); ++it)
    {
        cout << *it << " ";
    }
    cout << endl;
}

int main(int argc, const char * argv[]) {
    func({1,2,3,4,5,6});
    
    return 0;
}
```

### <font color=red size=4>14.基于范围的for循环</font>

```c++
vector<int> t{1,2,3,4};
for (auto item : t) //拷贝
{
    cout << item;
}
cout << endl;

for (auto &item : t) //引用
{
    cout << item;
}
cout << endl;

for (const auto &item : t) //只读引用
{
    cout << item;
}

////////////////////////////
map<int,string> m{{1,"andy"}, {2,"mike"}};
    
for (auto it = m.begin(); it!=m.end(); ++it) {
    cout << it->first << ", " << it->second;
}
cout << endl;
for(auto &it : m) {
    cout << it.first << " ," << it.second;
}
```
注意：set容器元素只读，map的key只读

### <font color=red size=4>15.可调用对象</font>
```c++
using namespace std;

/**
 1.函数指针
 */
void print(int a, string b) {
    
}

using funcptr = void(*)(int,string);

/**
 2.具有operator()成员函数的类对象（仿函数）
 */

/**
 3.可被转换为函数指针的类对象
 */

/**
 4.类的函数指针或者类的成员指针
 */
class Test {
public:
    //2.具有operator()成员函数的类对象（仿函数）
    void operator () (string msg) {
        cout << "仿函数：" << msg << endl;
    }
    
    //3.将类对象转换为函数指针
    operator funcptr() {
        //return hello;
        return world;
    }
    
    void hello(int a, string s) {
        
    }
    
    static void world(int a, string s) {
        cout << "num: " << a << " name:" << s << endl;
    }
    
    int m_i;
};


int main() {
    Test a;
    a("hello");
    
    Test tt;
    tt(1, "lucy");
    
    funcptr f = Test::world;
    
    using fptr = void(Test::*)(int, string);
    fptr f1 = &Test::hello;
    
    //类的成员指针
    using ptr = int Test::*;
    ptr p = &Test::m_i;
    
    Test ttt;
    (ttt.*f1)(1, "2");
    ttt.*p = 100;
    
    return 1;
}

```

### <font color=red size=4>16.可调用对象包装器function的使用</font>
```c++
//1.包装普通函数
function<void(int, string)> f1 = print;

//2.包装类的静态函数
function<void(int, string)> f2 = Test::world;

//3.包装仿函数
Test ta;
function<void(string)> f3 = ta;

//4.包装转化为函数指针的对象
Test tb;
function<void(int, string)> f4 = tb;

//调用
f1(1, "");
f2(2, "");
f3("");
f4(3, "");
```

### <font color=red size=4>17.可调用对象绑定器</font>
```c++
using namespace std;

void testFunc(int a, int b, const function<void(int, int)>& f) {
    f(a, b);
}

void output(int a, int b) {
    cout << a << "; " << b << endl;
}

class Test {
public:
    void output(int a, int b) {
        
    }
    
    int count(int a, int b) {
        return a+b;
    }
    
    int m_num = 100;
};

int main() {
    //绑定固定参数
    bind(output, 1, 2)();
    //绑定部分固定参数
    bind(output, 1, placeholders::_1)(12);
    bind(output, placeholders::_1, 2)(12);
    
    bind(output, placeholders::_1, placeholders::_2)(1, 2);
    
    auto f = bind(output, placeholders::_1, placeholders::_2);
    testFunc(1, 1, f);
    
    //成员函数绑定
    Test t;
    auto f2 = bind(&Test::output, &t, 520, placeholders::_1);
    f2(1);
    
    //成员变量
    auto f3 = bind(&Test::m_num, &t);
    f3();
    f3() = 666;
    
    //包装
    function<void(int, int)> b1 = f2;
    
    function<int(int, int)> b3 = bind(&Test::count, &t, 2, 2);
    
    function<int&(void)> b2 = f3; //包装的成员变量绑定器可读可写，所以为&
    b2();
    b2() = 888;
    
    return 1;
}
```


### <font color=red size=4>18.lambda表达式</font>
