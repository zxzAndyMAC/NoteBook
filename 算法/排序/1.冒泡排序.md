### 冒泡排序（Bubble Sort）
1. **冒泡排序（Bubble Sort）**
   * **是否原地排序：是**
   * **是否稳定：是**
   * **时间复杂度：O($n^2$)**
   * **空间复杂度：O(1)**
   冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。
   ![t](https://static001.geekbang.org/resource/image/92/09/9246f12cca22e5d872cbfce302ef4d09.jpg)
   **冒泡过程还可以优化,当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作,如下图。**
   ![t](https://static001.geekbang.org/resource/image/a9/e6/a9783a3b13c11a5e064c5306c261e8e6.jpg)
   ```c++
   void buuble_sort(int a[], int length)
   {
       if (length <= 1) return;

       for(int i=length-1; i>=0 ; i--)
       {
           bool flag = false; //标记
           for(int j=0; j<i; j++)
           {
               if(a[j] > a[j+1])
               {
                   int temp = a[j];
                   a[j] = a[j+1];
                   a[j+1] = temp;
                   flag = true;
               }
           }
           if(!flag)
           {
               break;
           }
       }
   }
   ```
   **冒泡排序的时间复杂度计算技巧：**
    通过 **“有序度”** 和 **“逆序度”** 这两个概念来进行分析。  

    **有序度**是数组中具有有序关系的元素对的个数。
    ![t](https://static001.geekbang.org/resource/image/a1/20/a1ef4cc1999d6bd0af08d8417ee55220.jpg)
    同理，对于一个倒序排列的数组，比如 6，5，4，3，2，1，有序度是 0；对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是 **n\*(n-1)/2**，也就是 15。我们把这种完全有序的数组的有序度叫作**满有序度**。  

    **逆序度**的定义正好跟有序度相反（默认从小到大为有序）
    我们还可以得到一个公式：**逆序度 = 满有序度 - 有序度**。我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。  
    
    对于包含 n 个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏情况下，初始状态的有序度是 0，所以要进行 n*(n-1)/2 次交换。最好情况下，初始状态的有序度是 n*(n-1)/2，就不需要进行交换。我们可以取个中间值 n*(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况。换句话说，平均情况下，需要 n*(n-1)/4 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 O(n2)，所以平均情况下的时间复杂度就是 O(n2)。 