### 归并排序（Merge Sort）
1. **归并排序（Merge Sort）**
   * **是否原地排序：否**
   * **是否稳定：是**
   * **时间复杂度：O(nlogn) (最好最坏都是O(nlogn))**
   * **空间复杂度：O(n)**
  归并排序的核心思想还是蛮简单的。如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。
  ![t](https://static001.geekbang.org/resource/image/db/2b/db7f892d3355ef74da9cd64aa926dc2b.jpg)
  归并排序使用的就是分治思想。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。  
  伪代码
  ```c++
    // 归并排序算法, A是数组，n表示数组大小
    merge_sort(A, n) {
    merge_sort_c(A, 0, n-1)
    }

    // 递归调用函数
    merge_sort_c(A, p, r) {
    // 递归终止条件
    if p >= r  then return

    // 取p到r之间的中间位置q
    q = (p+r) / 2
    // 分治递归
    merge_sort_c(A, p, q)
    merge_sort_c(A, q+1, r)
    // 将A[p...q]和A[q+1...r]合并为A[p...r]
    merge(A[p...r], A[p...q], A[q+1...r])
    }
  ```
  你可能已经发现了，merge(A[p...r], A[p...q], A[q+1...r]) 这个函数的作用就是，将已经有序的 A[p...q]和 A[q+1....r]合并成一个有序的数组，并且放入 A[p....r]。那这个过程具体该如何做呢？  
  如图所示，我们申请一个临时数组 tmp，大小与 A[p...r]相同。我们用两个游标 i 和 j，分别指向 A[p...q]和 A[q+1...r]的第一个元素。比较这两个元素 A[i]和 A[j]，如果 A[i]<=A[j]，我们就把 A[i]放入到临时数组 tmp，并且 i 后移一位，否则将 A[j]放入到数组 tmp，j 后移一位。  
  继续上述比较过程，直到其中一个子数组中的所有数据都放入临时数组中，再把另一个数组中的数据依次加入到临时数组的末尾，这个时候，临时数组中存储的就是两个子数组合并之后的结果了。最后再把临时数组 tmp 中的数据拷贝到原数组 A[p...r]中。  
  ![t](https://static001.geekbang.org/resource/image/95/2f/95897ade4f7ad5d10af057b1d144a22f.jpg)
  
  
  完整代码：
  ```c++
  void merge(int a[], int left, int middle, int right)
  {
      int* temp = new int[right-left+1];
      int i=left;
      int j=middle+1;
      int k = 0;
      while (i<=middle && j<=right) {
          if(a[i]<=a[j]){//<= 保持算法稳定的关键
              temp[k++] = a[i++];
              if(i>middle && j<=right)
              {
                  while(j<=right)
                  {
                      temp[k++] = a[j++];
                  }
                  break;
              }
          }
          else
          {
              temp[k++] = a[j++];
              if(i<=middle && j>right)
              {
                  while(i<=middle)
                  {
                      temp[k++] = a[i++];
                  }
                  break;
              }
          }
      }
      
      int size = right-left;
      for(int index=0; index<=size; index++)
      {
          a[left+index] = temp[index];
      }
      
      delete []temp;
  }

  void merge_sort_c(int a[], int left, int right)
  {
      if (left>=right) return;

      int middle = left + (right - left)/2;

      merge_sort_c(a, left, middle);
      merge_sort_c(a, middle+1, right);
      merge(a, left, middle, right);
  }

  void merge_sort(int a[], int length)
  {
      merge_sort_c(a, 0, length-1);
  }
  ```  
    
**归并排序的时间复杂度计算：**
归并排序涉及递归，时间复杂度的分析稍微有点复杂。我们正好借此机会来学习一下，如何分析递归代码的时间复杂度。  
  
在递归那一节我们讲过，递归的适用场景是，一个问题 a 可以分解为多个子问题 b、c，那求解问题 a 就可以分解为求解问题 b、c。问题 b、c 解决之后，我们再把 b、c 的结果合并成 a 的结果。  

如果我们定义求解问题 a 的时间是 T(a)，求解问题 b、c 的时间分别是 T(b) 和 T( c)，那我们就可以得到这样的递推关系式：
```
T(a) = T(b) + T(c) + K
```  
其中 K 等于将两个子问题 b、c 的结果合并成问题 a 的结果所消耗的时间。  
  
从刚刚的分析，我们可以得到一个重要的结论：不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。  
  
套用这个公式，我们来分析一下归并排序的时间复杂度。  
  
我们假设对 n 个元素进行归并排序需要的时间是 T(n)，那分解成两个子数组排序的时间都是 T(n/2)。我们知道，merge() 函数合并两个有序子数组的时间复杂度是 O(n)。所以，套用前面的公式，归并排序的时间复杂度的计算公式就是：  
```
T(1) = C；   n=1时，只需要常量级的执行时间，所以表示为C。
T(n) = 2*T(n/2) + n； n>1
```  
  
通过这个公式，如何来求解 T(n) 呢？还不够直观？那我们再进一步分解一下计算过程。  
  
```
T(n) = 2*T(n/2) + n
     = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n
     = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n
     = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n
     ......
     = 2^k * T(n/2^k) + k * n
     ......
```  
  
通过这样一步一步分解推导，我们可以得到 T(n) = $2^kT$(n/$2^k$)+kn。当 T(n/$2^k$)=T(1) 时，也就是 n/$2^k$=1，我们得到 k=log2n 。我们将 k 值代入上面的公式，得到 T(n)=Cn+nlog2n 。如果我们用大 O 标记法来表示的话，T(n) 就等于 O(nlogn)。所以归并排序的时间复杂度是 O(nlogn)。  
  
从我们的原理分析和伪代码可以看出，归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的，不管是最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)。
  
    
**归并排序的空间复杂度计算:**
归并排序的时间复杂度任何情况下都是 O(nlogn)，看起来非常优秀。（待会儿你会发现，即便是快速排序，最坏情况下，时间复杂度也是 O(n2)。）但是，归并排序并没有像快排那样，应用广泛，这是为什么呢？因为它有一个致命的“弱点”，那就是归并排序不是原地排序算法。  
  
这是因为归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。这一点你应该很容易理解。那我现在问你，归并排序的空间复杂度到底是多少呢？是 O(n)，还是 O(nlogn)，应该如何分析呢？  
  
如果我们继续按照分析递归时间复杂度的方法，通过递推公式来求解，那整个归并过程需要的空间复杂度就是 O(nlogn)。不过，类似分析时间复杂度那样来分析空间复杂度，这个思路对吗？  
  
实际上，递归代码的空间复杂度并不能像时间复杂度那样累加。刚刚我们忘记了最重要的一点，那就是，尽管每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 O(n)。 