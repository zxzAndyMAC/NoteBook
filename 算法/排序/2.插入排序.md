### 插入排序（Insertion Sort）
1. **插入排序（Insertion Sort）**
   * **是否原地排序：是**
   * **是否稳定：是**
   * **时间复杂度：O($n^2$)**
   * **空间复杂度：O(1)**
  我们将数组中的数据分为两个区间，**已排序区间**和**未排序区间**。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。如图所示，要排序的数据是 4，5，6，1，3，2，其中左侧为已排序区间，右侧是未排序区间。
  ![t](https://static001.geekbang.org/resource/image/b6/e1/b60f61ec487358ac037bf2b6974d2de1.jpg)
  插入排序也包含两种操作，一种是元素的比较，一种是元素的移动。当我们需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。  
    
  ```c++
  void insertion_sort(int a[], int length)
  {
      if (length <= 1) return;

      for(int i=1; i<length; i++)//初始化已排序空间只有一个元素，所以下标从1开始
      {
          int value = a[i];//空出a[i]位置，a[i]的值来自未排序区间
          int j=i-1;
          for(; j>=0; --j)
          {
              if(a[j] > value)
              {
                  a[j+1] = a[j];//因为之前在未排序空间空出了位置，往后搬移数据，空出当前a[j+1]位置
              }
              else
              {
                  break;
              }
          }
          a[j+1] = value;//将value放置空出来的a[j+1]位置
      }
  }
  ```
    
**为什么插入排序要比冒泡排序更受欢迎呢？**
我们前面分析冒泡排序和插入排序的时候讲到，冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。但是，从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。我们来看这段操作：
```c++

//冒泡排序中数据的交换操作：
if (a[j] > a[j+1]) { // 交换
int tmp = a[j];
a[j] = a[j+1];
a[j+1] = tmp;
flag = true;
}

//插入排序中数据的移动操作：
if (a[j] > value) {
a[j+1] = a[j];  // 数据移动
} else {
break;
}
```
我们把执行一个赋值语句的时间粗略地计为单位时间（unit_time），然后分别用冒泡排序和插入排序对同一个逆序度是 K 的数组进行排序。用冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，所以交换操作总耗时就是 3*K 单位时间。而插入排序中数据移动操作只需要 K 个单位时间。  

这个只是我们非常理论的分析，为了实验，针对上面的冒泡排序和插入排序的 Java 代码，我写了一个性能对比测试程序，随机生成 10000 个数组，每个数组中包含 200 个数据，然后在我的机器上分别用冒泡和插入排序算法来排序，冒泡排序算法大约 700ms 才能执行完成，而插入排序只需要 100ms 左右就能搞定！  
    
所以，虽然冒泡排序和插入排序在时间复杂度上是一样的，都是 O(n2)，但是如果我们希望把性能优化做到极致，那肯定首选插入排序。
  