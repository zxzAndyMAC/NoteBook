## <center>动态规划</center>
***
#### 1.能用动态规划解决的问题
如果一个问题满足以下两点，那么它就能用动态规划解决。
1. 问题的答案依赖于问题的规模，也就是问题的所有答案构成了一个数列。举个简单的例子，1个人有2条腿，2个人有4条腿，...，`n`个人有多少条腿？答案是`2n`条腿。这里的`2n`是问题的答案，`n`则是问题的规模，显然问题的答案是依赖于问题的规模的。答案是因变量，问题规模是自变量。因此，问题在所有规模下的答案可以构成一个数列`(f(1),f(2),...,f(n))`，比如刚刚“数腿”的例子就构成了间隔为2的等差数列`(0,2,4,6,...,2n)`.
2. 大规模问题的答案可以由小规模问题的答案递推得到，也就是`f(n)`的值可以由`{f(i)|i<n}`中的个别求得。还是刚刚“数腿”的例子，显然`f(n)`可以基于`f(n-1)`求得：`f(n) = f(n-1)+2`.

#### 2.适合用动态规划解决的问题
能用动态规划解决，不代表适合用。比如刚刚的“数腿”例子，你可以写成`f(n)=2n`的显式表达式形式，那么杀鸡就不必用牛刀了。但是，在许多场景`f(n)`的显式式子是不易得到的，大多数情况下甚至无法得到，动态规划的魅力就出来了。

***
### 应用动态规划——将动态规划拆分成三个子目标
当要应用动态规划来解决问题时，归根结底就是想办法完成以下三个关键目标。
#### 1.建立状态转移方程 
这一步是最难的，大部分人都被卡在这里。这一步没太多的规律可说，只需抓住一个思维：当做已经知道`f(1)~f(n-1)`的值，然后想办法利用它们求得`f(n)`。在“数腿”的例子中，状态转移方程即为`f(n)=f(n-1)+2`。
#### 2. 缓存并复用以往结果
这一步不难，但是很重要。如果没有合适地处理，很有可能就是指数和线性时间复杂度的区别。假设在“数腿”的例子中，我们不能用显式方程，只能用状态转移方程来解。如果现在`f(100)`未知，但是刚刚求解过一次`f(99)`。如果不将其缓存起来，那么求`f(100)`时，我们就必须花100次加法运算重新获取。但是如果刚刚缓存过，只需复用这个子结果，那么将只需一次加法运算即可。
#### 3. 按顺序从小往大算
这里的“小”和“大”对应的是问题的规模，在这里也就是我们要从`f(0), f(1)`, ...`f(n)` 到  依次顺序计算。这一点在“数腿”的例子来看，似乎显而易见，因为状态方程基本限制了你只能从小到大一步步递推出最终的结果（假设我们仍然不能用显式方程）。然而当问题复杂起来的时候，你有可能乱了套，所以必须记住这也是目标之一。

***
### 例子
#### 1.斐波那契数列（简单）
>斐波那契数列：0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233……
>它遵循这样的规律：当前值为前两个值的和。
>那么第`n`个值为多少？

首先，我们可以很容易得到状态转移方程`f(n) = f(n-1) + f(n-2)`。接下来我们用两种方法来做：

1. 简单递归(反例)
```python
def fib(n):
    if n < 2:
        return n
    else:
        return fib(n-1) + fib(n-2)
    
if __name__ == '__main__':
    result = fib(100)  # 你等到天荒地老，它还没有执行完
```

如上所示，代码简单易懂，然而这代码却极其低效。先不说这种递归的方式造成栈空间的极大浪费，就仅仅是该算法的时间复杂度已经属于O($n^2$)了。指数级别时间复杂度的算法跟不能用没啥区别！
为什么是指数时间复杂度？图1通过展示求解`f(6)`的过程说明了其原因。如图，随着递归的深入，计算任务不断地翻倍！
![图1 简单递归的执行过程](https://github.com/zxzAndyMAC/NoteBook/blob/master/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9B%BE1.png?raw=true)

2. 动态规划
   ```python
    def fib(n):
    
    results = list(range(n+1)) # 用于缓存以往结果，以便复用（目标2）

    for i in range(n+1):  # 按顺序从小往大算（目标3）
        if i < 2:
            results[i] = i
        else:
            # 使用状态转移方程（目标1），同时复用以往结果（目标2）
            results[i] = results[i-1] + results[i-2] 
        
    return results[-1]


    if __name__ == '__main__':
        result = fib(100)  # 秒算，result为：354224848179261915075
   ```
如上代码，针对动态规划的三个子目标，都很好地实现了（参考备注），具体为：
**目标1.** 建立状态转移方程（完成）。也就是前面的 `f(n) = f(n-1) + f(n-2)`
**目标2.** 缓存并复用以往结果（完成）。图1的简单递归存在大量的重复任务。在线性规划解法中，我们把结果缓存在results列表，同时在results[i] = results[i-1] + results[i-2]中进行了复用。这相当于我们只需完成图2中红色部分的计算任务即可，时间复杂度瞬间降为`O(n)`
![图2](https://github.com/zxzAndyMAC/NoteBook/blob/master/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9B%BE2.png?raw=true)

**目标3.** 按顺序从小往大算（完成）。for循环实现了从0到  的顺序求解，让问题按着从小规模往大规模求解的顺序走。

#### 2.不同路径（困难)
>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？

![图3](https://github.com/zxzAndyMAC/NoteBook/blob/master/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9B%BE3.png?raw=true)

>例如，上图是一个7 x 3 的网格。有多少可能的路径？

解这题，如前所述，我们需要完成三个子目标
1. 建立状态转移方程。该题就难在这里，这一步搞不定基本上GG了。实际上，如图3所示，第`i`行第`j`列的格子的路径数，是等于它左边格子和上面格子的路径数之和:`f(i,j) = f(i-1,j)+f(i,j-1)`。

![图3](https://github.com/zxzAndyMAC/NoteBook/blob/master/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9B%BE4.png?raw=trues)

2. 缓存并复用以往结果。与之前说的一维数列不同，这里的中间结果可以构成一个二维数列（如图3），所以需要用二维的数组或者列表来存储。
3. 按顺序从小往大算。这次有两个维度，所以需两个循环，分别逐行和逐列让问题从小规模到大规模计算。

以下是具体代码
```python
def count_paths(m, n):    
    results = [[1] * n] * m  # 将二维列表初始化为1，以便之后用于缓存（目标2）
    # 题外话：results的空间复杂度不是O(nm)，是O(n)
    
    # 第0行和第0列的格子路径数显然均取值为1，所以跳过
    for i in range(1, m):       # 外循环逐行计算（目标3）
        for j in range(1, n):   # 内循环逐列计算（目标3）    
            # 状态方程（目标1），以及中间结果复用（目标2）
            results[i][j] = results[i-1][j] + results[i][j-1]  
            
    return results[-1][-1]

if __name__ == '__main__':
    result = count_paths(7, 3) # 结果为28
```



